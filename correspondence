http://studygit.simbirsoft1.com/jom.everest/task_tracker_example/blob/master/controllers/edittask.controller.js#L17

У вас есть замечательный сервис TaskService который даже исходя из названия создан для работы с тасками. Так как он является синглтоном - данные хранимые в нём будут одинаковы во всё приложении. $rootScope не рекомендован для хранения всех данных.

Я знаю, что не рекомендуется хранить что попало в $scope, $rootScope. Да возможно стоило использовать TaskService или завести отдельный общий сервис для доступа к общим данным. Нет пока ясности как правильно организовать доступ.



http://studygit.simbirsoft1.com/jom.everest/task_tracker_example/blob/master/app-services/task.service.local-storage.js#L64

Нейминг. Названия мало что говорящие кроме как порядковый номер индекса который в принципе не несет особой информации. 

Да, наверное стоило придумать более говорящее названия например indexToUser или как-нибудь через один запрос перейти к необходимому объекту.



http://studygit.simbirsoft1.com/jom.everest/task_tracker_example/blob/master/app-services/task.service.local-storage.js#L54

Структуры данных. Что смутило - итоговой  структурой является "массив таскок значениями которого является массив тасок". Такая структура запутывает. Опять же одним из решений является вопрос нейминга, но можно обойти и сменив структуру.

Согласен, наименования в этой структуре запутывают. Изначально это был именно массив тасков только для одного пользователя, потом я решил немного расширить ее для многих, а название осталось.  



http://studygit.simbirsoft1.com/jom.everest/task_tracker_example/blob/master/app-services/task.service.local-storage.js#L62

Зачем создавать промисы когда асинхронности нет? Промис никогда не может быть реджекнут. Overhead.

Может быть я чего-то недопонимаю, но на обратной стороне, кто пользуется этим сервисом, ожидают что ответ будет в виде промиса, это же временное решение до тех пор пока не будут использоваться реальные асинхронные REST запросы к серверу. Или я чего-то недопонимаю.



http://studygit.simbirsoft1.com/jom.everest/task_tracker_example/blob/master/app-services/flash.service.js#L37-45

Такие вещи лучше оптимизировать написав метод setFlash принимающий в параметрах один аргумент configObject = {message, type, keepAfterLocationChange}

Спорно. Так нагляднее и яснее.



http://studygit.simbirsoft1.com/jom.everest/task_tracker_example/blob/master/app-services/authentication.service.js#L64

А чем не устроили методы btoa() / atob() ?

Еще бы я знал что это такое. Ну теперь после вопроса я догадываюсь. Код аутентификации был взят мной из интернета, т.к. я слабо себе представляю как правильно проводить процедуру идентификации пользователя и не было много времени копать в этом направлении. И зачем вообще вставлять в заголовок http запроса закодированные пользовательские аутентификационные данные?



http://studygit.simbirsoft1.com/jom.everest/task_tracker_example/blob/master/app-services/authentication.service.js#L24

Интересная авторизация. Отправить имя пользователя и посмотреть на стороне фронта сравнить его пароль. Такая авторизация ломается за 2 действия. 

Отправляем известный нам username, смотрим пароль в Network, отправляем с известным нам паролем.

Угу :). Это ведь не рабочий код, а вставлен для имитации входа пользователя в систему, чтобы проверить как все будет выглядеть. В рабочем, т.е. работающим с сервером все это замениться на

$http.post('/api/authenticate', { username: username, password: hashpassword })
  .success(function (response) {
      callback(response);
});
хотя, возможно и этого не достаточно от взлома
